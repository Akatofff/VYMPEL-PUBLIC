//---------------------------------------------------------------------------
#ifndef skeleton_h
#define skeleton_h
//---------------------------------------------------------------------------
#define RAD_IN_DEG 0.017453292519943295769
//---------------------------------------------------------------------------
#include <windows.h>
#include <GL\gl.h>
#include <list>
#include <vector>
#include "vector.h"
//---------------------------------------------------------------------------
//#define SHOW_NORMALS

#ifdef SHOW_NORMALS
#define NORMAL_SIZE 5000
#endif
//---------------------------------------------------------------------------
/*
минимальное значение радиуса
минимальная разница между углами, высотами
так же для сферы: минимальное значение угла u, минимальная разница между 180 град. и углом u
так же для альтернативного вычисления нормалей: минимальное расстояние между точками при котором любая из них не может быть использована в качестве базы для вычисления нормалей
*/
extern float skeleton_eps;

struct skeleton
{
    typedef float f2[2];
    typedef float f3[3];
    typedef unsigned short us4[4];

    f3 **vertex;
    f3 **normal;
    f2 **tex;
    us4 **idx;
    int u_count; //кол-во сечений по параметру u
    int v_count; //кол-во сечений по параметру v

    bool render_lines;
    bool render_facets;

    skeleton(void);
    virtual ~skeleton(void);

    void render(void);
};

/*
нормаль к поверхности заданной параметрически
x = x(u, v)
y = y(u, v)
z = z(u, v)

|  i      j      k      |
|  dx/du  dy/du  dz/du  |
|  dx/dv  dy/dv  dz/dv  |

n = A i + B j + C k

A = dy/du * dz/dv - dz/du * dy/dv
B = dz/du * dx/dv - dx/du * dz/dv
C = dx/du * dy/dv - dy/du * dx/dv
*/

void get_normal
(
    float *x, float *y, float *z,
    float dx_du, float dx_dv,
    float dy_du, float dy_dv,
    float dz_du, float dz_dv
);

void create_ellipsoid
(
    skeleton *s,
    float rx, //полуось x
    int u_count,
    int v_count,
    float u_1 = 0, //угол по высоте (между вектором от начала координат до точки на поверхности и осью z)
    float u_2 = 180,
    float v_1 = 0, //угол по окружности (обход против часовой стрелки вокруг оси z, 0 соответствует оси x)
    float v_2 = 360,
    float rry = 1, //отношение полуоси y к полуоси x
    float rrz = 1 //отношение полуоси y к полуоси x
);

/*
цилиндр, конус (rx_2 = 0), усеченный конус, диск (rx_2 = u_1 = u_2 = 0), кольцо
порядок вершин и нормалей в массивах обратный (от 2 к 1)
*/
void create_elliptical_cylinder
(
    skeleton *s,
    float rx_1, //полуось x по высоте
    float rx_2,
    int u_count,
    int v_count,
    float u_1, //высота
    float u_2,
    float v_1 = 0, //угол по окружности (обход против часовой стрелки вокруг оси z, 0 соответствует оси x)
    float v_2 = 360,
    float rry_1 = 1, //отношение полуоси y к полуоси x по высоте
    float rry_2 = 1
);

void create_elliptical_torus
(
    skeleton *s,
    float R,
    float rx_1, //полуось x по большой окружности
    float rx_2,
    int u_count,
    int v_count,
    float u_1 = 0, //угол по большой окружности (обход против часовой стрелки вокруг оси z, 0 соответствует оси x)
    float u_2 = 360,
    float v_1 = 0, //угол по малой окружности (обход против часовой стрелки если смотреть в направлении оси -y на окружность с центром -R)
    float v_2 = 360,
    float rry_1 = 1, //отношение полуоси y к полуоси x по большой окружности
    float rry_2 = 1
);

/*
ящик (стенка)
порядок вершин и нормалей в массивах обратный (сверху вниз)
*/
void create_box
(
    skeleton *s,
    float dx,
    float dy,
    float dz
);

void create_idxes(skeleton *s);

//дополнительное усреднение
enum n_avg_t
{
    u_1_2_n_avg = 1, //изолинии с u = u_1 и u = u_2 совпадают - нормали вершин лежащих на этих изолиниях усредняются
    v_1_2_n_avg = 2, //изолинии с v = v_1 и v = v_2 совпадают - нормали вершин лежащих на этих изолиниях усредняются
    u_1_n_avg = 4, //все точки изолинии с u = u_1 совпадают - нормали вершин лежащих на этой изолинии усредняются
    u_2_n_avg = 8, //все точки изолинии с u = u_2 совпадают - нормали вершин лежащих на этой изолинии усредняются
    v_1_n_avg = 16, //все точки изолинии с u = v_1 совпадают - нормали вершин лежащих на этой изолинии усредняются
    v_2_n_avg = 32 //все точки изолинии с u = v_2 совпадают - нормали вершин лежащих на этой изолинии усредняются
};
/*
альтернатива аналитическому вычислению нормалей:
для каждой грани нормаль получается как векторное произведение ребер грани
для каждой вершины нормаль получается как среднее нормалей граней в которые входит эта вершина
после получения нормалей они могут быть дополнительно усреднены по швам 
*/
void create_normals
(
    skeleton *s,
    int n_avg //возможно задание нескольких независимых дополнительных усреднений
);
//---------------------------------------------------------------------------
#endif //g_utils_h
